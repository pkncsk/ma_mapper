{
    "sourceFile": "docs/package_docs.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1753102963447,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1753103290657,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -194,20 +194,67 @@\n \tgenomewide_data_path = '/path/to/maf/directory/'\r\n \t\r\n \tmaf_data_matrix=mapper.map_and_overlay(alignment_filepath, genomewide_data_path,data_format='maf',separated_maf=True, count_arg='common_freq', target_species='hg38', \r\n \tcol_threshold = 0.10, col_content_threshold = 0.10, row_threshold = 0.10)\r\n-\\end{minted}  \r\n-Similarly, \\texttt{separated\\_maf} toggle allows either per-chromosome \\texttt{MAF} files or a single file extraction. For separated \\texttt{MAF} extraction, users must provide directory path. The \\texttt{target\\_species} argument sets the reference genome, for example, \\texttt{hg38} for the human genome in the updated Zoonomia dataset. \r\n+```\r\n+Similarly, `separated_maf` toggle allows either per-chromosome `MAF` files or a single file extraction. For separated `MAF` extraction, users must provide directory path. The `target_species` argument sets the reference genome, for example, `hg38` for the human genome in the updated Zoonomia dataset. \r\n \r\n-The texttt{count\\_arg} parameter control the format at nucleotide level. Avialable options are:\r\n-\\begin{itemize}[noitemsep, topsep=0pt]\r\n-\t\\item \\texttt{ref\\_freq}: reference base frequency\r\n-\t\\item \\texttt{coverage}: number of species aligned (not to be confused with sequencing coverage)\r\n-\t\\item \\texttt{common\\_freq}: most common base frequency\r\n-\t\\item \\texttt{common\\_freq\\_nogap}: same as above, excluding gaps from total count\r\n-\t\\item \\texttt{common\\_raw}: raw count of the most common base\r\n-\t\\item \\texttt{base\\_count}: all base counts\r\n-\t\\item \\texttt{base\\_freq}: all base frequencies\r\n-\t\\item \\texttt{base\\_freq\\_nogap}: all base frequencies excluding gaps\r\n-\t\\item \\texttt{raw}: returns a \\texttt{pandas.DataFrame} with alignment content at each position\r\n-\t\\item \\texttt{raw\\_genome} same as \\texttt{raw} but only with genome names only, excluding chromosome labels.\r\n-\\end{itemize}\r\n+The `count_arg` parameter control the format at nucleotide level. Avialable options are:\r\n+- `ref_freq`: reference base frequency\r\n+- `coverage`: number of species aligned (not to be confused with sequencing coverage)\r\n+- `common_freq`: most common base frequency\r\n+- `common_freq_nogap`: same as above, excluding gaps from total count\r\n+- `common_raw`: raw count of the most common base\r\n+- `base_count`: all base counts\r\n+- `base_freq`: all base frequencies\r\n+- `base_freq_nogap`: all base frequencies excluding gaps\r\n+- `raw`: returns a `pandas.DataFrame` with alignment content at each position\r\n+- `raw_genome` same as `raw` but only with genome names only, excluding chromosome labels.\r\n+\r\n+\r\n+## Visualization\r\n+The `plots` module was used to visualize the resulting data matrix from the previous step. The code below is the intended simplest representation of the matrix.  \r\n+\r\n+```python\r\n+\tfrom ma_mapper import plots\r\n+\tfrom ma_mapper import mapper\r\n+\tplots.plot(\r\n+\tdata = [bigwig_data_matrix], \r\n+\talignment=filtered_alignment_matrix,\r\n+\tshow_alignment=False, \r\n+\theatmap_color=['RdBu'],\r\n+\theatmap_mode='overlay',\r\n+\theatmap_title=['Example of plot function'],\r\n+\theatmap_title_fs = 10, \r\n+\theatmap_xlabel = 'position (bp)',\r\n+\theatmap_xlabel_fs = 10,\r\n+\theatmap_ylabel = 'sequences',\r\n+\theatmap_ylabel_fs = 10,\r\n+\tvlim = [[-1,1]], \r\n+\tcolorbar=True,\r\n+\tcolorbar_steps=[0.1]\r\n+\t)\r\n+```  \r\n+\r\n+Slicing/Cropping for specific parts of the plot is possible using plot coordinates, as shown below:\r\n+```python\r\n+\tfrom ma_mapper import plots\r\n+\tfrom ma_mapper import mapper\r\n+\tplots.plot(\r\n+\tdata = [bigwig_data_matrix], \r\n+\talignment=filtered_alignment_matrix,\r\n+\tshow_alignment=False, \r\n+\theatmap_color=['RdBu'],\r\n+\theatmap_mode='overlay',\r\n+\theatmap_title=['Example of plot function'],\r\n+\theatmap_title_fs = 10, \r\n+\theatmap_xlabel = 'position (bp)',\r\n+\theatmap_xlabel_fs = 10,\r\n+\theatmap_ylabel = 'sequences',\r\n+\theatmap_ylabel_fs = 10,\r\n+\tvlim = [[-1,1]], \r\n+\tcolorbar=True,\r\n+\tcolorbar_steps=[0.1],\r\n+\txlim=[200,250],\r\n+\tylim=[1000,2000]\r\n+\t)\r\n+``` \r\n"
                },
                {
                    "date": 1753103703986,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -233,8 +233,9 @@\n \tcolorbar=True,\r\n \tcolorbar_steps=[0.1]\r\n \t)\r\n ```  \r\n+<img src=\"img/2athe1cmas.png\" alt=\"THE1C alignment\" style=\"width:40%;\" />\r\n \r\n Slicing/Cropping for specific parts of the plot is possible using plot coordinates, as shown below:\r\n ```python\r\n \tfrom ma_mapper import plots\r\n@@ -254,7 +255,12 @@\n \tvlim = [[-1,1]], \r\n \tcolorbar=True,\r\n \tcolorbar_steps=[0.1],\r\n \txlim=[200,250],\r\n-\tylim=[1000,2000]\r\n \t)\r\n ``` \r\n+\r\n+<img src=\"img/2athe1cmaszoom.png\" alt=\"THE1C alignment\" style=\"width:40%;\" />\r\n+\r\n+Additionally, the metadata table which contains TE coordinates, can be expanded further with additional information from either external sources or other data matrices transfromed into row-wise data arrays and subsequently converted into plot annotation \r\n+\r\n+See the tutorials [here](https://github.com/pkncsk/ma_mapper/blob/experimental/script/documentation/tutorial_nb/00overview.md) for more complex usages such as multiple matrix overlays or row annotation.\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753103969878,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,12 +2,23 @@\n \r\n ## Quick links\r\n - [Input preparation](#input-preparation)\r\n     - [TE coordinates](#te-coordinates)\r\n-    - [Transposable element multiple sequeunce alignment](#transposable-element-multiple-sequeunce-alignment-te-msa)\r\n+    - [Transposable element multiple sequeunce alignment (TE MSA)](#transposable-element-multiple-sequeunce-alignment-te-msa)\r\n     - [Genome-wide datasets](#genome-wide-datasets)\r\n         - [`BED` file](#bed-file)\r\n-        - [`BAM` ]\r\n+        - [`BAM` file](#bam-file)\r\n+        - [`BIGWIG` file](#bigwig-file)\r\n+        - [`VCF` file](#vcf-file)\r\n+        - [`MAF` file](#maf-file)\r\n+- [TE MSA conversion](#te-msa-conversion)\r\n+- [Data extraction and mapping](#data-extraction-and-mapping)\r\n+    - [`BED` file](#bed-file-1)\r\n+    - [`BAM` file](#bam-file-1)\r\n+    - [`BIGWIG` file](#bigwig-file-1)\r\n+    - [`VCF` file](#vcf-file-1)\r\n+    - [`MAF` file](#maf-file-1)\r\n+- [Visualization](#visualization)\r\n \r\n ## Input preparation\r\n TE coordinates, TE MSA, and genome-wide dataset are required for the pipeline. Although there are different methods to prepare these files, the format requirement for each input file, and the preparation method and used including parameters and options in each showcase are outlined below:\r\n \r\n"
                }
            ],
            "date": 1753102963447,
            "name": "Commit-0",
            "content": "# Package Documentation\r\n\r\n## Quick links\r\n- [Input preparation](#input-preparation)\r\n    - [TE coordinates](#te-coordinates)\r\n    - [Transposable element multiple sequeunce alignment](#transposable-element-multiple-sequeunce-alignment-te-msa)\r\n    - [Genome-wide datasets](#genome-wide-datasets)\r\n        - [`BED` file](#bed-file)\r\n        - [`BAM` ]\r\n\r\n## Input preparation\r\nTE coordinates, TE MSA, and genome-wide dataset are required for the pipeline. Although there are different methods to prepare these files, the format requirement for each input file, and the preparation method and used including parameters and options in each showcase are outlined below:\r\n\r\n### TE coordinates\r\nThe requirements for this input is to be in BED-like format (`chromosome`, `start`, `end`, and `strand` must be present) and optionally provide unique ID for TE entries. It is possible for one ID to have multiple entries in the table as the package supports fragment joining. Critically, the ID from TE coordinate should be the same as TE sequence ID in TE MSA. \r\n\r\nFor the testing sample, the coordinates for THE1C TEs were obtained from [RepeatMasker output](https://www.repeatmasker.org/genomes/hg38/RepeatMasker-rm405-db20140131/hg38.fa.out.gz). The header rows were edited from two rows into one rows to facilitate importing by `pandas`. After importing, the THE1C entries were extracted from the table using `ma_mapper.sequence_alignment`. This module is a wrapper for `biopython.SeqIO` and `MAFFT` to streamline the sequence alignment process.\r\n\r\n```python\r\n\tfrom ma_mapper import sequence_alignment\r\n\t\r\n\tcoord_table=sequence_alignment.extract_coord_from_repeatmasker_table(\r\n\tsubfamily = 'THE1C',\r\n\trepeatmasker_table = '/path/to/repeatmasker/output/file/',\r\n\tsave_to_file = False\r\n\t)\r\n```\r\nThe resulting `coord_table` is a `pandas.DataFrame` object that is in BED format and compatible with the pipeline. To save the table to a file, users can provide a destination path via `save_to_file`.\r\n\r\n### Transposable element multiple sequeunce alignment (TE MSA)\r\nThe TEA MSA file is required to be in FASTA format with a header specifically generated using their coordinate:     `>ID::chromosome:start-end(strand)` to ensure proper row syncing across matrices in the downstream analyses. For this package, the `ma_mapper.sequence_io()` was used to extract sequence from the [human reference genome (`hg38`) obtained from UCSC](https://hgdownload.cse.ucsc.edu/goldenpath/hg38/bigZips/hg38.fa.gz).\r\n\r\n```python\r\n\tfrom ma_mapper import sequence_alignment\r\n\t\r\n\tte_seqeunces=sequence_alignment.sequence_io(\r\n\tcoordinate_table=coord_table,\r\n\tsource_fasta='/path/to/hg38/fasta',\r\n\tsave_to_file='/target/path/for/TE/sequences')\r\n```\r\n\r\n`coordinate_table` can accept both a dataframe (as produced in the previous step) and a path to BED file. Although the function returns a `SeqIO` object, it is recommended to save the result as a FASTA file for use in the next step.\r\n\r\nThen, the multiple sequence alignment was performed on TE sequences using `ma_mapper.sequence_alignment.mafft_align`.\r\n\r\n```python\r\n\tfrom ma_mapper import sequence_alignment\r\n\t\r\n\tsequence_alignment.mafft_align(\r\n\tinput_filepath='/path/to/TE/sequences',\r\n\tnthread=6,\r\n\toutput_filepath='/target/path/for/TE/alignment'\r\n\t)\r\n```\r\n\r\nThe output was saved in FASTA format. Users can adjust multithread parameters using `nthread, nthreadb, nthreadit` and provide additional flags using `mafft_arg` argument.\r\n\r\n### Genome-wide datasets\r\nTo show case the capability of the framework, genome-wide datasets in this thesis were obtained from various publicly available sources as follows:\r\n\r\n#### `BED` file\r\nAn example of `BED` file was obtained from [HOMER transcription factor motif prediction](http://homer.ucsd.edu/homer/data/motifs/homer.KnownMotifs.hg38.191020.bed.gz). The table was then separated by motif names into smaller table for efficient data retrieval.\r\n\r\n#### `BAM` file \r\nAn example `BAM` file was generated from ZNF267 ChIP-exo derived from [KZFP overexpression experiments](https://www.ncbi.nlm.nih.gov/sra?term=SRX2512744). The `FASTQ` file, retrieved from Sequence Read Archive (SRA) was mapped to [`GRCh38_noalt_as` reference genome](https://genome-idx.s3.amazonaws.com/bt/GRCh38\\_noalt\\_as.zip) using `bowtie2`. Subsequently, the mapped reads in `SAM` format was converted into `BAM`, then sorted and indexed by `samtools`. The read mapping operation was performed with default settings as shown below:\r\n\r\n```bash\r\n\t# Step 1: Align with Bowtie2\r\n\tbowtie2 --threads 128 --local -x GRCh38_noalt_as -U /path/to/fastq/ -S /target/path/to/sam/\r\n\t# Step 2: Convert SAM to BAM\r\n\tsamtools view -@ 128 -bS /target/path/to/sam/ > /target/path/to/bam/\r\n\t# Step 3: Sort BAM\r\n\tsamtools sort -@ 128 -o /target/path/to/sam/sorted/ /target/path/to/sam/\r\n\t# Step 4: Index BAM\r\n\tsamtools index /target/path/to/sam/sorted/\r\n```\r\n#### `BIGWIG` file\r\nAn example of `BigWig` file, a [phyloP track of Zoonomia multispecies alignment , was obtained from UCSC database](http://hgdownload.cse.ucsc.edu/goldenPath/hg38/phyloP447way) and was used without modification.\r\n\r\n#### `VCF` file\r\nExample `VCF` files were obtained from [the gnomAD database](https://gnomad.broadinstitute.org/data#v3) and stored in the same directory. After downloading, these files were indexed by `tabix` for efficient data retrieval.\r\n\r\nThe following snippet is the command for VCF file indexing:\r\n```bash\r\n\ttabix -p vcf /path/to/zipped/vcf/file/\r\n```\r\n\r\n#### `MAF` file\r\n\\label{mafprep}\r\nExample `MAF` files of [the updated Zoonomia dataset obtained from UCSC database](https://hgdownload.soe.ucsc.edu/goldenPath/hg38/cactus447way/maf/). As `MafIO.MafIndex()` does not support a compressed `MAF` file, all files were unzipped before indexing for fast data retrieval. For this framework, `.mafindex` files are required to have exactly the same name as their `.maf` counterparts as shown below.\r\n```bash\r\n\tchr1.maf\r\n\tchr1.mafindex\r\n\t...\r\n\tchrY.maf\r\n\tchrY.mafindex\r\n```\r\n\r\nThe MAF files were indexed using the code snippet below:\r\n```python\r\n\t# build mafindex file \r\n\tfrom bio import MafIO\r\n\tmaf_file = '/path/to/maf/'\r\n\ttarget_species = 'hg38'\r\n\tmaf_id = f'{target_species}.{chrom}'\r\n\tmafindex_filedir = '.'.join(str.split(maf_file, sep='.')[:-1]) #remove .maf \r\n\tmafindex_filepath = f'{mafindex_filedir}.mafindex'\r\n\tindex_maf = MafIO.MafIndex(mafindex_filepath, maf_file, maf_id) \r\n```  \r\n\r\n\r\n## TE MSA conversion\r\nAlignment conversion is mandatory for data mapping as the numerical alignment matrix is needed as a reference for gap position. The input for this step is the aligned FASTA file with specific sequence header `>ID::chromosome:start-end(strand)`. \r\n\r\n```python\r\n\tfrom ma_mapper import mapper\r\n\talignment_filepath = '/path/to/alignment/fasta/'\r\n\t\r\n\tfiltered_alignment_matrix, alignment_coordinate  = mapper.parse_and_filter(alignment_file=alignment_filepath,col_threshold = 0.10, col_content_threshold = 0.10, row_threshold = 0.10)\r\n``` \r\n\r\nThe outputs of this step are a filtered numerical alignment matrix `numpy.ndarray` and a metadata table `pandas.DataFrame`. By default, these outputs are already filtered internally. For pre-filtered output, users can toggle the `preprocess_out` argument to make the function returns a pre-filtered numerical alignment matrix, a pre-filtered metadata, and filters.\r\n\r\nFiltering behavior is customizable with several arguments:\r\n- `filter`: enable/disable filtering\r\n- `row_threshold`: set the row threshold\r\n- `col_threshold`: set the column threshold\r\n- `col_content_threshold`: sets the minimum non-gap content for a column\r\n\r\nAdditionally, to examine regions beyond TE boundaries, users can specify the extension length and the path to the genome sequence for sequence extraction using `extension` and `source_fasta` arguments respectively.      \r\n\r\n## Data extraction and Mapping\r\nThe inputs for this step are the numerical alignment matrix, a path to genome-wide data file, and a type of file. Regardless of input type, this function always outputs a numerical data matrix that has the same gapped position as the numerical alignment matrix. The specific handling and parameters for each supported file type is described below.\r\n\r\n### `BED` file\r\n```python\r\n\talignment_filepath = '/path/to/alignment/fasta'\r\n\tgenomewide_data_filepath = '/path/to/bed/file/'\r\n\t\r\n\tfiltered_alignment_matrix, alignment_coordinate  = mapper.parse_and_filter(alignment_file=alignment_filepath,col_threshold = 0.10, col_content_threshold = 0.10, row_threshold = 0.10)\r\n\tbed_data_matrix=mapper.map_and_overlay(alignment_filepath, genomewide_data_filepath,data_format='bed',strand_overlap=True, \r\n\tcol_threshold = 0.10, col_content_threshold = 0.10, row_threshold = 0.10)\r\n``` \r\nSome genome-wide dataset `BED` files may lack strand information (i.e., `.` instead of `+,-`). The `strand_overlap` argument can be used to enable/disable strand-specific processing.\r\n\r\n### `BAM` file\r\n\r\n```python\r\n\talignment_filepath = '/path/to/alignment/fasta'\r\n\tgenomewide_data_filepath = '/path/to/bam/file/'\r\n\t\r\n\tfiltered_alignment_matrix, alignment_coordinate  = mapper.parse_and_filter(alignment_file=alignment_filepath,col_threshold = 0.10, col_content_threshold = 0.10, row_threshold = 0.10)\r\n\tdata_matrix_forward=mapper.map_and_overlay(alignment_filepath, genomewide_data_filepath,data_format='read_forward', \r\n\tcol_threshold = 0.10, col_content_threshold = 0.10, row_threshold = 0.10)\r\n\tdata_matrix_reverse=mapper.map_and_overlay(alignment_filepath, genomewide_data_filepath,data_format='read_reverse', \r\n\tcol_threshold = 0.10, col_content_threshold = 0.10, row_threshold = 0.10)\r\n```\r\n\r\nFor `BAM` files, users can choose to separate `read_forward` and `read_reverse` or the combined `read_sum`. Smoothing is also supported via `normal_forward` and `normal_reverse` with parameters for for probe length `probe_length` and smoothing length `smoothing_length`. \r\n\r\nEven though `BAM` files are recommended to be preprocessed before using this pipeline, basic filtering using `pysam` internal flags is supported. Users can enable arguments such as:\r\n- `drop_duplicate`: remove duplicate reads\r\n- `drop_unmapped`: remove unmapped reads\r\n- `drop_2`: remove secondary/supplementary reads\r\n- `drop_multipmap`: remove multimapped reads\r\n\r\nAll filters are disabled by default.\r\n\r\n\r\n### `BigWig` file\r\n```python\r\n\talignment_filepath = '/path/to/alignment/fasta'\r\n\tgenomewide_data_filepath = '/path/to/bigwig/file/'\r\n\t\r\n\tfiltered_alignment_matrix, alignment_coordinate  = mapper.parse_and_filter(alignment_file=alignment_filepath,col_threshold = 0.10, col_content_threshold = 0.10, row_threshold = 0.10)\r\n\tbigwig_data_matrix=mapper.map_and_overlay(alignment_filepath, genomewide_data_filepath,data_format='bigwig', \r\n\tcol_threshold = 0.10, col_content_threshold = 0.10, row_threshold = 0.10)\r\n```  \r\nThere is no additional parameter for `BigWig`.\r\n\r\n### `VCF` file\r\n```python\r\n\talignment_filepath = '/path/to/alignment/fasta'\r\n\tgenomewide_data_path = '/path/to/vcf/directory/'\r\n\t\r\n\tvcf_data_matrix=mapper.map_and_overlay(alignment_filepath, genomewide_data_path,data_format='vcf',query_key='AF',vcf_format='gnomad', \r\n\tcol_threshold = 0.10, col_content_threshold = 0.10, row_threshold = 0.10)\r\n```\r\nHere, `vcf_format` argument has two options, one for gnomAD dataset (fully supported) and another for direct file extraction. For gnomAD extraction, users have to provide directory path to gnomAD `VCF` files. Other than alternate allele frequency value, `query_key` argument also allows the users to access other fields.\r\n\r\n### `MAF` file\r\n```python\r\n\talignment_filepath = '/path/to/alignment/fasta'\r\n\tgenomewide_data_path = '/path/to/maf/directory/'\r\n\t\r\n\tmaf_data_matrix=mapper.map_and_overlay(alignment_filepath, genomewide_data_path,data_format='maf',separated_maf=True, count_arg='common_freq', target_species='hg38', \r\n\tcol_threshold = 0.10, col_content_threshold = 0.10, row_threshold = 0.10)\r\n\\end{minted}  \r\nSimilarly, \\texttt{separated\\_maf} toggle allows either per-chromosome \\texttt{MAF} files or a single file extraction. For separated \\texttt{MAF} extraction, users must provide directory path. The \\texttt{target\\_species} argument sets the reference genome, for example, \\texttt{hg38} for the human genome in the updated Zoonomia dataset. \r\n\r\nThe texttt{count\\_arg} parameter control the format at nucleotide level. Avialable options are:\r\n\\begin{itemize}[noitemsep, topsep=0pt]\r\n\t\\item \\texttt{ref\\_freq}: reference base frequency\r\n\t\\item \\texttt{coverage}: number of species aligned (not to be confused with sequencing coverage)\r\n\t\\item \\texttt{common\\_freq}: most common base frequency\r\n\t\\item \\texttt{common\\_freq\\_nogap}: same as above, excluding gaps from total count\r\n\t\\item \\texttt{common\\_raw}: raw count of the most common base\r\n\t\\item \\texttt{base\\_count}: all base counts\r\n\t\\item \\texttt{base\\_freq}: all base frequencies\r\n\t\\item \\texttt{base\\_freq\\_nogap}: all base frequencies excluding gaps\r\n\t\\item \\texttt{raw}: returns a \\texttt{pandas.DataFrame} with alignment content at each position\r\n\t\\item \\texttt{raw\\_genome} same as \\texttt{raw} but only with genome names only, excluding chromosome labels.\r\n\\end{itemize}\r\n"
        }
    ]
}